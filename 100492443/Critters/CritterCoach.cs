using CritterRobots.Critters.Controllers;
using CritterRobots.Forms;
using CritterRobots.Messages;
using MachineLearning;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Timers;
using System.Windows.Forms;

namespace CritterRobots.Critters
{
	/// <summary>
	/// This critter handles picking the best
	/// critter from a generation.
	/// </summary>
	public class CritterCoach : Critter
	{
		/// <summary>
		/// Shows the "Best critter" dialog window.
		/// If set to false, the contents of the dialog will be logged to the debugger.
		/// </summary>
		public bool ShowBestCritterDialog { get; set; } = false;

		/// <summary>
		/// The active teacher critter.
		/// </summary>
		public static CritterCoach Coach { get; private set; }

		/// <summary>
		/// The amount of students registered.
		/// </summary>
		public int StudentsCount {
			get
			{
				return CritterStudents.Count;
			}
		}

		/// <summary>
		/// Container for all the critter students.
		/// </summary>
		private List<CritterStudent> CritterStudents { get; } = new List<CritterStudent>();

		/// <summary>
		/// Neural networks stored from the best of the top 5 in the previous generation to the
		/// worst of the top 5 in the previous generations.
		/// </summary>
		private ConcurrentQueue<NeuralNetwork> NetworksQueue { get; } = new ConcurrentQueue<NeuralNetwork>();

		/// <summary>
		/// Represents a method that selects which
		/// component of the student should be used as a discriminator
		/// to determine which critter student is more fit in the set.
		/// </summary>
		// private delegate double CritterFitnessDiscriminator(CritterStudent student);

		/// <summary>
		/// Sends out periodical time check requests.
		/// </summary>
		private System.Timers.Timer TimeChecker { get; set; }

		/// <summary>
		/// Indicates whether or not this teacher has already picked a winner.
		/// </summary>
		private bool HasFinished { get; set; } = false;

		/// <summary>
		/// The directory in which the previous brains will be located.
		/// </summary>
		private string PreviousBrainsDirectory => Filepath + "Previous Generation" + Path.DirectorySeparatorChar;

		/*
		/// <summary>
		/// Informs that the selected student has successfully
		/// escaped.
		/// </summary>
		/// <param name="studentID">The ID of the critter that escaped.</param>
		public void SetStudentEscaped(int studentID)
		{
			if (studentID >= 0 && studentID < CritterStudents.Count)
			{
				CritterStudents[studentID].HasEscaped = true;
				CritterStudent.AnyEscaped = true;
			}
		}
		*/

		/// <summary>
		/// Fills the networks queue with the specified number of random networks.
		/// </summary>
		/// <param name="count"></param>
		private void FillNetworks(int count)
		{
			while (count > 0)
			{
				NeuralNetwork nextNetwork = NeuralNetwork.RandomNetwork(
					inputNeurons: NeuralCritter.NetworkInput,
					outputNeurons: NeuralCritter.NetworkOutput,
					minLayers: 0,
					maxLayers: 2,
					minNeurons: 1,
					maxNeurons: 3
				);

				NetworksQueue.Enqueue(nextNetwork);
				count--;
			}
		}

		/// <summary>
		/// Fills in the networks queue.
		/// </summary>
		private void GenerateNetworks(int studentsCount)
		{
			// The top 5 critters from the previous generation + 5 critters generated by mutating the best critter in
			// the previous generation + 1 critter generated at random are the minimum number of critters to form a
			// generation that could make sense.
			if (studentsCount < 11)
			{
				throw new InvalidDataException("The generation size is too small to generate Neural Networks for it. Please increase it to at least 11.");
			}

			if (Directory.Exists(Filepath + "Previous Generation"))
			{
				StringBuilder messageBuilder = new StringBuilder("Loading new generation:" + Environment.NewLine);

				foreach (var serializedNetwork in Directory.GetFiles(Filepath + "Previous Generation", "*.crbn").OrderBy(network => network))
				{
					using (StreamReader brainReader = new StreamReader(serializedNetwork))
					{
						messageBuilder.Append("Loading brain ").Append(serializedNetwork).Append(" into location #").AppendLine(NetworksQueue.Count.ToString());

						string serializedBrain = brainReader.ReadToEnd();
						NeuralNetwork nextNetwork = NeuralNetwork.Deserialize(serializedBrain);
						NetworksQueue.Enqueue(nextNetwork);

						studentsCount--;
					}
				}

				SaveGenerationLog(messageBuilder.ToString());
				
				NetworksQueue.TryPeek(out NeuralNetwork bestNetwork);
				string serializedBestNetwork = bestNetwork.Serialize();

				while (studentsCount > 1)
				{
					NeuralNetwork nextNetwork = NeuralNetwork.Deserialize(serializedBestNetwork);
					nextNetwork.Mutate(5);
					NetworksQueue.Enqueue(nextNetwork);

					studentsCount--;
				}

				FillNetworks(1);
			}
			else
			{
				FillNetworks(studentsCount);
			}
		}

		/// <summary>
		/// Creates a teacher critter.
		/// </summary>
		public CritterCoach(int critterCount) : base("Coach!")
		{
			Coach = this;
			GenerateNetworks(critterCount);
		}

		/// <summary>
		/// Logs a student critter to this teacher's attention.
		/// </summary>
		/// <param name="student">The student to be logged.</param>
		public void AddStudent(CritterStudent student)
		{
			CritterStudents.Add(student);
			student.CritterBrain = AllocateNeuralNetwork();
		}

		/// <summary>
		/// Allocates a new neural network from the networks queue.
		/// </summary>
		public NeuralNetwork AllocateNeuralNetwork()
		{
			if (NetworksQueue.Count > 0)
			{
				NetworksQueue.TryDequeue(out NeuralNetwork nextNetwork);
				return nextNetwork;
			}

			return null;
		}

		/// <summary>
		/// No specific UI.
		/// </summary>
		public override void LaunchUI()
		{
			CoachWindow coachWindow = new CoachWindow(this);
			coachWindow.Show();
			coachWindow.Focus();
		}

		/// <summary>
		/// Set up timer.
		/// </summary>
		protected override void OnInitialize()
		{
			TimeChecker = new System.Timers.Timer(1000);
			TimeChecker.Elapsed += (sender, e) => Responder("GET_LEVEL_TIME_REMAINING:0");
			TimeChecker.Start();
		}

		/*
		/// <summary>
		/// Returns the best student given a filter and a discriminator.
		/// </summary>
		/// <param name="filter">Filtering rules to only select critters that match this criteria.</param>
		/// <param name="discriminator">The discriminator by which the best critter is picked.</param>
		/// <param name="bestFitness">The best fitness detected in this generation.</param>
		private CritterStudent GetBestStudent(Predicate<double> filter, CritterFitnessDiscriminator discriminator, out double bestFitness)
		{
			bestFitness = 0.0f;
			CritterStudent bestCritter = null;

			foreach (var studentCritter in CritterStudents)
			{
				double currentFitness = discriminator(studentCritter);
				if (filter(currentFitness) && currentFitness > bestFitness)
				{
					bestFitness = currentFitness;
					bestCritter = studentCritter;
				}
			}

			return bestCritter;
		}
		*/

		/// <summary>
		/// Returns the 5 best students in this generation based on their score.
		/// </summary>
		/// <returns>The best critters in this generation.</returns>
		private IEnumerable<CritterStudent> GetBestStudents()
		{
			foreach(CritterStudent student in CritterStudents.OrderByDescending(critter => critter.Score).Take(5))
			{
				yield return student;
			}
		}

		/// <summary>
		/// Saves this generation's general information log to a file.
		/// </summary>
		/// <param name="log">The contents of the generation's log.</param>
		private void SaveGenerationLog(string log)
		{
			using (StreamWriter writer = new StreamWriter(Filepath + "generation.log", true))
			{
				writer.WriteLine(log + Environment.NewLine);
			}
		}

		/// <summary>
		/// Picks the winner for this generation and stops working.
		/// </summary>
		public void FinishGeneration()
		{
			int studentID = 1;
			StringBuilder fullMessageBuilder = new StringBuilder("Round complete. The 5 best students are as follows:" + Environment.NewLine);

			string[] ordinals = new string[] { "st", "nd", "rd", "th" };

			if (!Directory.Exists(PreviousBrainsDirectory))
			{
				Directory.CreateDirectory(PreviousBrainsDirectory);
			}

			foreach (CritterStudent bestStudent in GetBestStudents())
			{
				string serializedBrain = bestStudent.CritterBrain.Serialize();
				string serializedFileName = "best_brain_snapshot_" + studentID + ".crbn";

				fullMessageBuilder.Append(studentID).Append(ordinals[Math.Min(ordinals.Length - 1, studentID - 1)]).Append(": ").Append(bestStudent.Name).Append(", with a score of ").AppendLine(bestStudent.Score.ToString());

				using (StreamWriter brainWriter = new StreamWriter(PreviousBrainsDirectory + serializedFileName))
				{
					brainWriter.Write(serializedBrain);
				}

				studentID++;
			}

			if (ShowBestCritterDialog)
			{
				MessageBox.Show(fullMessageBuilder.ToString(), "Coach!", MessageBoxButtons.OK, MessageBoxIcon.Information);
			}
			else
			{
				SaveGenerationLog(fullMessageBuilder.ToString());
			}

			TimeChecker.Stop();
			HasFinished = true;
		}

		/// <summary>
		/// Get information on the best performing critter and
		/// save its brain.
		/// </summary>
		protected override void OnTimeRemainingUpdate(double timeRemaining)
		{
			if (timeRemaining < 2.0 && !HasFinished)
			{
				FinishGeneration();
			}
		}

		/// <summary>
		/// Gets information on the best performing critter and saves its brain.
		/// </summary>
		protected override void OnStop(string stopReason)
		{
			if (!HasFinished)
			{
				FinishGeneration();
			}
		}
	}
}
